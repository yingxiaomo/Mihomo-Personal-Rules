name: Train and Deploy Smart Model
on:
  push:
    branches:
      - main
    paths:
      - 'smart_trainer/**'
      - '.github/workflows/train.yml'
  schedule:
    - cron: '30 22 * * *'
  workflow_dispatch:
permissions:
  contents: write
  id-token: write
jobs:
  train_and_deploy:
    runs-on: ubuntu-latest
    env:
      RCLONE_CONFIG_B64: ${{ secrets.RCLONE_CONFIG_B64 }}
      REMOTE: ${{ secrets.REMOTE }}
      LATEST_TAG: smart-model
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 
      - name: Set up Python 3.12
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r smart_trainer/requirements.txt
      - name: Set up rclone config
        run: |
          echo "$RCLONE_CONFIG_B64" | base64 -d > rclone.conf
      - name: Download and Install rclone
        run: |
          curl -Of https://downloads.rclone.org/rclone-current-linux-amd64.zip
          unzip rclone-current-linux-amd64.zip
          RCLONE_DIR=$(find . -maxdepth 1 -type d -name "rclone-v*-linux-amd64")
          sudo mv "$RCLONE_DIR"/rclone /usr/bin/rclone
          rclone version
      - name: Pull CSV from Google Drive
        run: |
          rclone copy "$REMOTE" ./data --config rclone.conf --transfers=4 --checkers=8 --log-level=INFO
      - name: Check for CSV data files
        run: |
          if [ ! -d ./data ] || [ -z "$(ls -A ./data)" ]; then
            echo "::error::Data directory is empty or not found. Cannot proceed with training."
            exit 1
          fi
      - name: Run training script
        id: training
        run: |
          set -o pipefail
          python smart_trainer/train_smart.py --output-file Model.bin 2>&1 | tee training_log.txt
      - name: Upload model artifact
        if: success() 
        uses: actions/upload-artifact@v4
        with:
          name: model-artifact
          path: Model.bin
      - name: Configure Git
        if: success()
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
      - name: Update Tag
        if: success()
        run: |
          git push --delete origin "$LATEST_TAG" 2>/dev/null || true  
          git tag -f "$LATEST_TAG"
          git push origin "$LATEST_TAG"
      - name: Create Release
        if: success()
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.LATEST_TAG }}
          name: Smart Model
          files: Model.bin
          body: |
            âœ¨ æ°¸ä¹…æ¨¡å‹é“¾æ¥å·²æ›´æ–°ã€‚
            - æ¨¡å‹æºæäº¤: ${{ github.sha }}
            - è®­ç»ƒè¿è¡Œ ID: ${{ github.run_id }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Send Notification
        if: always() 
        env:
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
          JOB_STATUS: ${{ job.status }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          LATEST_TAG: ${{ env.LATEST_TAG }}
          LOG_FILE: "training_log.txt"
        run: |
          python -c '
          import os
          import urllib.request
          import urllib.parse
          import sys
          import shutil
          token = os.environ.get("TG_BOT_TOKEN")
          chat_id = os.environ.get("TG_CHAT_ID")
          status = os.environ.get("JOB_STATUS")
          run_id = os.environ.get("GITHUB_RUN_ID")
          repo = os.environ.get("GITHUB_REPOSITORY")
          server_url = os.environ.get("GITHUB_SERVER_URL")
          tag = os.environ.get("LATEST_TAG")
          log_file = os.environ.get("LOG_FILE")
          if not token or not chat_id:
              print("::warning::Telegram Token or Chat ID is missing. Skipping notification.")
              sys.exit(0)
          def send_msg(text):
              url = f"https://api.telegram.org/bot{token}/sendMessage"
              payload = {
                  "chat_id": chat_id,
                  "text": text,
                  "parse_mode": "HTML",
                  "disable_web_page_preview": "true"
              }
              data = urllib.parse.urlencode(payload).encode("utf-8")
              req = urllib.request.Request(url, data=data)
              try:
                  with urllib.request.urlopen(req) as response:
                      print(f"Message sent: {response.status}")
              except Exception as e:
                  print(f"Failed to send message: {e}")
          if status == "success":
              header = f"""<b>ğŸ‰ æ¨¡å‹å‘å¸ƒæˆåŠŸï¼</b>
              ğŸ”— GitHub Release å·²æ›´æ–°ã€‚
              <a href="{server_url}/{repo}/releases/tag/{tag}">æŸ¥çœ‹ Release</a>
              """
          else:
              header = f"""<b>ğŸš¨ æ¨¡å‹éƒ¨ç½²/è®­ç»ƒå¤±è´¥ï¼</b>
              âŒ ä»»åŠ¡è¿è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ã€‚
              <a href="{server_url}/{repo}/actions/runs/{run_id}">æŸ¥çœ‹è¯¦ç»†è¿è¡Œè®°å½•</a>
              """
          send_msg(header)
          if os.path.exists(log_file):
              try:
                  with open(log_file, "r", encoding="utf-8", errors="ignore") as f:
                      content = f.read()
                  if not content.strip():
                      send_msg("<i>(æ—¥å¿—æ–‡ä»¶ä¸ºç©º)</i>")
                  else:
                      chunk_size = 3000
                      if len(content) > chunk_size:
                          for i in range(0, len(content), chunk_size):
                              chunk = content[i:i+chunk_size]
                              send_msg(f"<pre>{chunk}</pre>")
                      else:
                          send_msg(f"<pre>{content}</pre>")
              except Exception as e:
                  send_msg(f"è¯»å–æ—¥å¿—æ–‡ä»¶å‡ºé”™: {str(e)}")
          else:
              send_msg(f"âš ï¸ æ‰¾ä¸åˆ°æ—¥å¿—æ–‡ä»¶: {log_file} (å¯èƒ½åœ¨è®­ç»ƒå¼€å§‹å‰å°±å´©æºƒäº†)")
          if os.path.exists("rclone.conf"):
              os.remove("rclone.conf")
          if os.path.exists("./data"):
              shutil.rmtree("./data", ignore_errors=True)
          '
